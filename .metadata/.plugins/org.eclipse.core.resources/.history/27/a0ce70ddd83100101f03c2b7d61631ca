package controller;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.PauseTransition;
import javafx.animation.Timeline;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.util.Duration;
import model.player.Player;

import java.net.URL;
import java.util.ResourceBundle;

public class MainGameController implements Initializable {

    // FXML injected nodes based on MainGameScene.fxml
    @FXML private Label currentTurnLabel;
    @FXML private Label nextTurnLabel;
    @FXML private ListView<String> playerListView;
    @FXML private HBox handCardsBox;
    @FXML private AnchorPane gameBoardPane;
    @FXML private Pane firePitPane;
    @FXML private Label statusMessageLabel;

    // The game engine handles game rules, turns, the board state, etc.
    private GameEngine gameEngine;
    
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        // Initialize the game engine and its state.
        gameEngine = new GameEngine();
        
        // Set up the game board layout (cells, zones, etc.).
        setupGameBoard();
        
        // Update initial UI according to the game engine state.
        updateTurnIndicators();
        updatePlayerInfo();
        updateHandCards();
        updateFirePit();
    }
    
    /**
     * Initializes the game board (cells and zones).
     * In a complete implementation, you may generate the 100-cell
     * track and special zones by dynamically adding Nodes to gameBoardPane.
     */
    private void setupGameBoard() {
        gameBoardPane.getChildren().clear();
        // Example: dynamically create cells or load them via a layout builder.
        // This is a placeholder that you can replace with your board initialization.
    }
    
    /**
     * Updates the labels that indicate the current and next player.
     */
    private void updateTurnIndicators() {
        // Retrieve players from the game engine.
        String currentPlayer = gameEngine.getCurrentPlayer().getName();
        String nextPlayer = gameEngine.getNextPlayer().getName();
        currentTurnLabel.setText("Current Turn: " + currentPlayer);
        nextTurnLabel.setText("Next Player: " + nextPlayer);
        
        // Refresh the player list with name, color, and remaining cards.
        playerListView.getItems().clear();
        for (Player player : gameEngine.getPlayers()) {
            String info = player.getName() + " - " + player.getColor() 
                    + " - Cards left: " + player.getHandSize();
            playerListView.getItems().add(info);
        }
    }
    
    /**
     * Updates the "hand" display for the human player.
     * Each card is shown as a button with its name and rank.
     */
    private void updateHandCards() {
        handCardsBox.getChildren().clear();
        for (Card card : gameEngine.getHumanPlayer().getHand()) {
            Button cardButton = new Button(card.getName() + " (" + card.getRank() + ")");
            cardButton.setOnAction(e -> handleCardSelection(card));
            handCardsBox.getChildren().add(cardButton);
        }
    }
    
    /**
     * Updates the fire pit display to show the top (last discarded) card.
     */
    private void updateFirePit() {
        Card topCard = gameEngine.getFirePitTopCard();
        firePitPane.getChildren().clear();
        if (topCard != null) {
            Label cardLabel = new Label(topCard.getName() + " " + topCard.getRank());
            firePitPane.getChildren().add(cardLabel);
        }
    }
    
    /**
     * Updates player information such as remaining cards and status.
     */
    private void updatePlayerInfo() {
        updateTurnIndicators();
        // Additional updates (such as marble counts or special statuses)
        // can be added here.
    }
    
    /**
     * Called when a human player selects a card.
     * @param card the selected card.
     */
    private void handleCardSelection(Card card) {
        // Mark the selected card in the game engine.
        gameEngine.setSelectedCard(card);
        statusMessageLabel.setText("Selected card: " + card.getName());
    }
    
    /**
     * Handler for when the human player clicks "End Turn".
     * Validates and processes the move and then advances the turn.
     */
    @FXML
    private void handleEndTurn() {
        if (!gameEngine.isHumanTurn()) {
            statusMessageLabel.setText("It's not your turn.");
            return;
        }
        
        try {
            // Process the human player's turn â€“ validate the move, update marble positions.
            Move move = gameEngine.processHumanMove();
            if (move != null) {
                // Animate marble movement based on move details.
                animateMarbleMove(move.getMarbleNode(), 
                                  move.getStartX(), move.getStartY(),
                                  move.getTargetX(), move.getTargetY());
            }
        } catch (InvalidMoveException ex) {
            // Show an error dialog without stopping the game flow.
            showErrorDialog("Invalid Move", ex.getMessage());
            return;
        }
        
        // Clear selections to prepare for the next move.
        resetSelections();
        
        // Advance the turn after a short delay so the player can observe the action.
        PauseTransition pause = new PauseTransition(Duration.seconds(1));
        pause.setOnFinished(event -> {
            gameEngine.advanceTurn();
            updateTurnIndicators();
            updateHandCards();
            updateFirePit();
            
            // If the next turn belongs to a CPU player, simulate its turn.
            if (!gameEngine.isHumanTurn()) {
                handleCpuTurn();
            }
        });
        pause.play();
    }
    
    /**
     * Processes a CPU player's turn by selecting a random card/move.
     * Uses a delay to simulate thinking and then animates the move.
     */
    private void handleCpuTurn() {
        PauseTransition pause = new PauseTransition(Duration.seconds(1.5));
        pause.setOnFinished(event -> {
            Move cpuMove = gameEngine.processCpuMove();
            if (cpuMove != null) {
                animateMarbleMove(cpuMove.getMarbleNode(), 
                                  cpuMove.getStartX(), cpuMove.getStartY(),
                                  cpuMove.getTargetX(), cpuMove.getTargetY());
            }
            
            updatePlayerInfo();
            updateFirePit();
    
            gameEngine.advanceTurn();
            updateTurnIndicators();
            updateHandCards();
            
            if (gameEngine.checkWinCondition()) {
                showWinDialog(gameEngine.getWinner());
            }
        });
        pause.play();
    }
    
    /**
     * Animates a marble's move from one position to another.
     * Uses a Timeline for smooth linear animation.
     *
     * @param marbleNode the Node representing the marble.
     * @param startX the starting x-coordinate.
     * @param startY the starting y-coordinate.
     * @param targetX the target x-coordinate.
     * @param targetY the target y-coordinate.
     */
    private void animateMarbleMove(Node marbleNode, double startX, double startY, double targetX, double targetY) {
        // Set marble to start position.
        marbleNode.setTranslateX(startX);
        marbleNode.setTranslateY(startY);
        if (!gameBoardPane.getChildren().contains(marbleNode)) {
            gameBoardPane.getChildren().add(marbleNode);
        }
        
        KeyValue kvX = new KeyValue(marbleNode.translateXProperty(), targetX);
        KeyValue kvY = new KeyValue(marbleNode.translateYProperty(), targetY);
        KeyFrame kf = new KeyFrame(Duration.seconds(0.5), kvX, kvY);
        Timeline timeline = new Timeline(kf);
        timeline.setOnFinished(event -> {
            // Update the game engine with the marble's new coordinates.
            gameEngine.updateMarblePosition(marbleNode, targetX, targetY);
            updatePlayerInfo();
        });
        timeline.play();
    }
    
    /**
     * Resets all card and marble selections in the model and UI.
     */
    private void resetSelections() {
        gameEngine.clearSelections();
        statusMessageLabel.setText("");
        // Optionally: remove any visual indications of selection.
    }
    
    /**
     * Handler for when the "Restart Game" button is clicked.
     * Resets the game engine and UI to the initial state.
     */
    @FXML
    private void handleRestartGame() {
        gameEngine.resetGame();
        setupGameBoard();
        updateTurnIndicators();
        updateHandCards();
        updateFirePit();
        statusMessageLabel.setText("Game restarted.");
    }
    
    /**
     * Displays an error popup dialog for invalid actions.
     * @param title the title of the popup.
     * @param msg the message that indicates why the action failed.
     */
    private void showErrorDialog(String title, String msg) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(msg);
        alert.showAndWait();
    }
    
    /**
     * Displays a win dialog when a player meets the win condition.
     * @param winner the winning player.
     */
    private void showWinDialog(Player winner) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Victory!");
        alert.setHeaderText(null);
        alert.setContentText("Winner: " + winner.getName() + " (" + winner.getColor() + ")");
        alert.showAndWait();
        // Optionally, you can prompt to restart the game here.
    }
}